{"version":3,"file":"static/js/session_trace-aggregate.31669986.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/utils/handler-cache.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/index.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/shared/replay-mode.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js","../node_modules/@babel/runtime/helpers/esm/classApplyDescriptorSet.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/constants';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/**\n * A class to defer callback execution until a decision can be reached\n */\nexport class HandlerCache {\n  /** @private @type {boolean | undefined} */\n  #decision = undefined;\n  /** @private @type {Function[]} */\n  #cache = [];\n  /** @private @type {Timeout} */\n  #settleTimer = setTimeout(() => this.#close(), 5000);\n  #noMoreChanges = false;\n\n  /**\n   * tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #drain() {\n    this.#cache.forEach(h => h());\n    this.#close();\n  }\n\n  /**\n   * tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #close() {\n    this.#cache = [];\n    clearTimeout(this.#settleTimer);\n  }\n\n  /**\n   * Wrap callback functions with this method to defer their execution until a decision has been reached\n   * @param {Function} handler\n   * @returns {void}\n   */\n  settle(handler) {\n    if (this.#decision === false) {\n      // Do nothing\n    } else if (this.#decision === undefined) this.#cache.push(handler);else handler();\n  }\n\n  /**\n   * Make a decision about what to do with the cache of callbacks.\n   * --- if true: tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache ---\n   * --- if false: tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @param {boolean} decision\n   */\n  decide(decision) {\n    if (this.#noMoreChanges) return;\n    this.#decision = decision;\n    if (decision === false) this.#close();\n    if (decision === true) this.#drain();\n  }\n  permanentlyDecide(decision) {\n    if (this.#noMoreChanges) return;\n    this.decide(decision);\n    this.#noMoreChanges = true;\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { getConfigurationValue, getRuntime } from '../../../common/config/config';\nimport { now } from '../../../common/timing/now';\nimport { FEATURE_NAME } from '../constants';\nimport { HandlerCache } from '../../utils/handler-cache';\nimport { getSessionReplayMode } from '../../session_replay/shared/replay-mode';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { MODE, SESSION_EVENTS } from '../../../common/session/constants';\nconst ignoredEvents = {\n  // we find that certain events make the data too noisy to be useful\n  global: {\n    mouseup: true,\n    mousedown: true\n  },\n  // certain events are present both in the window and in PVT metrics.  PVT metrics are prefered so the window events should be ignored\n  window: {\n    load: true,\n    pagehide: true\n  },\n  // when ajax instrumentation is disabled, all XMLHttpRequest events will return with origin = xhrOriginMissing and should be ignored\n  xhrOriginMissing: {\n    ignoreAll: true\n  }\n};\nconst toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n};\nconst MAX_TRACE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst REQ_THRESHOLD_TO_SEND = 30;\nconst ERROR_MODE_SECONDS_WINDOW = 30 * 1000; // sliding window of nodes to track when simply monitoring (but not harvesting) in error mode\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  #scheduler;\n  constructor(agentIdentifier, aggregator, argsObj) {\n    var _this;\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    _this = this;\n    this.agentRuntime = getRuntime(agentIdentifier);\n\n    // Very unlikely, but in case the existing XMLHttpRequest.prototype object on the page couldn't be wrapped.\n    if (!this.agentRuntime.xhrWrappable) return;\n    this.resourceObserver = argsObj?.resourceObserver; // undefined if observer couldn't be created\n    this.ptid = '';\n    this.trace = {};\n    this.nodeCount = 0;\n    this.sentTrace = null;\n    this.harvestTimeSeconds = getConfigurationValue(agentIdentifier, 'session_trace.harvestTimeSeconds') || 10;\n    this.maxNodesPerHarvest = getConfigurationValue(agentIdentifier, 'session_trace.maxNodesPerHarvest') || 1000;\n    /**\n     * Standalone (mode) refers to the legacy version of ST before the idea of 'session' or the Replay feature existed.\n     * It has some different behavior vs when used in tandem with replay. */\n    this.isStandalone = false;\n    const operationalGate = new HandlerCache(); // acts as a controller-intermediary that can enable or disable this feature's collection dynamically\n    const sessionEntity = this.agentRuntime.session;\n    this.operationalGate = operationalGate;\n\n    /* --- The following section deals with user sessions concept & contains non-trivial control flow. --- */\n    const controlTraceOp = traceMode => {\n      switch (traceMode) {\n        case MODE.ERROR:\n          this.startTracing(operationalGate, true);\n          break;\n        case MODE.FULL:\n        case true:\n          this.startTracing(operationalGate);\n          break;\n        case MODE.OFF:\n        case false:\n        default:\n          // this feature becomes \"off\" (does nothing & nothing is sent)\n          operationalGate.decide(false);\n          break;\n      }\n    };\n    let seenAnError = false;\n    let mostRecentModeKnown;\n    this.ee.on(SESSION_EVENTS.UPDATE, (eventType, sessionState) => {\n      // this will only have an effect if ST is NOT already in full mode\n      if (sessionState.sessionReplayMode === MODE.FULL) switchToFull();\n    });\n\n    /**\n     * The goal of switchToFull is to take external input to trigger a change from off or error to full.\n     * It will have no effect if already running in full mode.\n     * \"external\" input in this case means errors thrown on the page or session replay itself being triggered to run in full mode by the API, which updates the session entity.\n     */\n    const switchToFull = () => {\n      if (this.agentRuntime?.session?.state?.sessionReplayMode !== MODE.FULL) return;\n      if (mostRecentModeKnown !== MODE.FULL) {\n        const prevMode = mostRecentModeKnown;\n        mostRecentModeKnown = MODE.FULL;\n        sessionEntity.write({\n          sessionTraceMode: mostRecentModeKnown\n        });\n        this.isStandalone = false;\n        if (prevMode === MODE.ERROR && this.#scheduler) {\n          this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // up until now, Trace would've been just buffering nodes up to max, which needs to be trimmed to last X seconds\n          this.#scheduler.runHarvest({\n            needResponse: true\n          });\n        } else {\n          controlTraceOp(MODE.FULL);\n        }\n      }\n    };\n    if (!sessionEntity) {\n      // Since session manager isn't around, do the old Trace behavior of waiting for RUM response to decide feature activation.\n      this.isStandalone = true;\n      registerHandler('rumresp-stn', on => controlTraceOp(on), this.featureName, this.ee);\n    } else {\n      registerHandler('errorAgg', () => {\n        seenAnError = true;\n        switchToFull();\n      }, this.featureName, this.ee);\n      const stopTracePerm = () => {\n        if (sessionEntity.state.sessionTraceMode !== MODE.OFF) sessionEntity.write({\n          sessionTraceMode: MODE.OFF\n        });\n        operationalGate.permanentlyDecide(false);\n        if (mostRecentModeKnown === MODE.FULL) this.#scheduler?.runHarvest(); // allow queued nodes (past opGate) to final harvest, unless they were buffered in other modes\n        this.#scheduler?.stopTimer(true); // the 'true' arg here will forcibly block any future call to runHarvest, so the last runHarvest above must be prior\n        this.#scheduler = null;\n      };\n\n      // CAUTION: everything inside this promise runs post-load; event subscribers must be pre-load aka synchronous with constructor\n      this.waitForFlags(['stn', 'sr']).then(async _ref => {\n        let [traceOn, replayOn] = _ref;\n        if (!replayOn) {\n          // When sr = 0 from BCS, also do the old Trace behavior:\n          this.isStandalone = true;\n          controlTraceOp(traceOn);\n        } else {\n          this.ee.on('REPLAY_ABORTED', () => stopTracePerm());\n          /* Assuming on page visible that the trace mode is updated from shared session,\n           - if trace is turned off from the other page, it should be likewise here.\n           - if trace switches to Full mode, harvest should start (prev: Error) if not already running (prev: Full). */\n          this.ee.on(SESSION_EVENTS.RESUME, () => {\n            const updatedTraceMode = sessionEntity.state.sessionTraceMode;\n            if (updatedTraceMode === MODE.OFF) stopTracePerm();else if (updatedTraceMode === MODE.FULL && this.#scheduler && !this.#scheduler.started) this.#scheduler.runHarvest({\n              needResponse: true\n            });\n            mostRecentModeKnown = updatedTraceMode;\n          });\n          this.ee.on(SESSION_EVENTS.PAUSE, () => {\n            mostRecentModeKnown = sessionEntity.state.sessionTraceMode;\n          });\n          if (!sessionEntity.isNew) {\n            // inherit the same mode as existing session's Trace\n            if (sessionEntity.state.sessionReplayMode === MODE.OFF) this.isStandalone = true;\n            controlTraceOp(mostRecentModeKnown = sessionEntity.state.sessionTraceMode);\n          } else {\n            // for new sessions, see the truth table associated with NEWRELIC-8662 wrt the new Trace behavior under session management\n            const replayMode = await getSessionReplayMode(agentIdentifier);\n            if (replayMode === MODE.OFF) this.isStandalone = true; // without SR, Traces are still subject to old harvest limits\n\n            let startingMode;\n            if (traceOn === true) {\n              // CASE: both trace (entitlement+sampling) & replay (entitlement) flags are true from RUM\n              startingMode = MODE.FULL; // always full capture regardless of replay sampling decisions\n            } else {\n              // CASE: trace flag is off, BUT it must still run if replay is on (possibly)\n              // At this point, it's possible that 1 or more exception was thrown, in which case just start in full if Replay originally started in ERROR mode.\n              if (replayMode === MODE.ERROR && seenAnError) startingMode = MODE.FULL;else startingMode = replayMode;\n            }\n            sessionEntity.write({\n              sessionTraceMode: mostRecentModeKnown = startingMode\n            });\n            controlTraceOp(startingMode);\n          }\n        }\n      });\n    }\n    /* --- EoS --- */\n\n    // register the handlers immediately... but let the handlerCache decide if the data should actually get stored...\n    registerHandler('bst', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return operationalGate.settle(() => _this.storeEvent(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstResource', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return operationalGate.settle(() => _this.storeResources(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstHist', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return operationalGate.settle(() => _this.storeHist(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstXhrAgg', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return operationalGate.settle(() => _this.storeXhrAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstApi', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return operationalGate.settle(() => _this.storeSTN(...args));\n    }, this.featureName, this.ee);\n    registerHandler('errorAgg', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return operationalGate.settle(() => _this.storeErrorAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('pvtAdded', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return operationalGate.settle(() => _this.processPVT(...args));\n    }, this.featureName, this.ee);\n    this.drain();\n  }\n  startTracing(startupBuffer) {\n    let dontStartHarvestYet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof PerformanceNavigationTiming !== 'undefined') {\n      this.storeTiming(window.performance.getEntriesByType('navigation')[0]);\n    } else {\n      this.storeTiming(window.performance.timing);\n    }\n    this.#scheduler = new HarvestScheduler('resources', {\n      onFinished: this.#onHarvestFinished.bind(this),\n      retryDelay: this.harvestTimeSeconds\n    }, this);\n    this.#scheduler.harvest.on('resources', this.#prepareHarvest.bind(this));\n    if (dontStartHarvestYet === false) this.#scheduler.runHarvest({\n      needResponse: true\n    }); // sends first stn harvest immediately\n    startupBuffer.decide(true); // signal to ALLOW & process data in EE's buffer into internal nodes queued for next harvest\n  }\n  #onHarvestFinished(result) {\n    if (result.sent && result.responseText && !this.ptid) {\n      // continue interval harvest only if ptid was returned by server on the first\n      this.agentRuntime.ptid = this.ptid = result.responseText;\n      this.#scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    if (result.sent && result.retry && this.sentTrace) {\n      // merge previous trace back into buffer to retry for next harvest\n      Object.entries(this.sentTrace).forEach(_ref2 => {\n        let [name, listOfSTNodes] = _ref2;\n        if (this.nodeCount >= this.maxNodesPerHarvest) return;\n        this.nodeCount += listOfSTNodes.length;\n        this.trace[name] = this.trace[name] ? listOfSTNodes.concat(this.trace[name]) : listOfSTNodes;\n      });\n      this.sentTrace = null;\n    }\n  }\n  #prepareHarvest(options) {\n    if (this.isStandalone) {\n      if (this.ptid && now() >= MAX_TRACE_DURATION) {\n        // Perform a final harvest once we hit or exceed the max session trace time\n        options.isFinalHarvest = true;\n        this.operationalGate.permanentlyDecide(false);\n        this.#scheduler.stopTimer(true);\n      } else if (this.ptid && this.nodeCount <= REQ_THRESHOLD_TO_SEND && !options.isFinalHarvest) {\n        // Only harvest when more than some threshold of nodes are pending, after the very first harvest, with the exception of the last outgoing harvest.\n        return;\n      }\n    } else {\n      //   -- *cli May '26 - Update: Not rate limiting backgrounded pages either for now.\n      //   if (this.ptid && document.visibilityState === 'hidden' && this.nodeCount <= REQ_THRESHOLD_TO_SEND) return\n\n      const currentMode = this.agentRuntime.session.state.sessionTraceMode;\n      /* There could still be nodes previously collected even after Trace (w/ session mgmt) is turned off. Hence, continue to send the last batch.\n       * The intermediary controller SHOULD be already switched off so that no nodes are further queued. */\n      if (currentMode === MODE.OFF && Object.keys(this.trace).length === 0) return;\n      if (currentMode === MODE.ERROR) return; // Trace in this mode should never be harvesting, even on unload\n    }\n    return this.takeSTNs(options.retry);\n  }\n\n  // PageViewTiming (FEATURE) events and metrics, such as 'load', 'lcp', etc. pipes into ST here.\n  processPVT(name, value, attrs) {\n    this.storeTiming({\n      [name]: value\n    });\n    if (hasFID(name, attrs)) this.storeEvent({\n      type: 'fid',\n      target: 'document'\n    }, 'document', value, value + attrs.fid);\n    function hasFID(name, attrs) {\n      return name === 'fi' && !!attrs && typeof attrs.fid === 'number';\n    }\n  }\n\n  // This processes the aforementioned PVT and the first navigation entry of the page.\n  storeTiming(timingEntry) {\n    if (!timingEntry) return;\n\n    // loop iterates through prototype also (for FF)\n    for (let key in timingEntry) {\n      let val = timingEntry[key];\n\n      // ignore size and status type nodes that do not map to timestamp metrics\n      const lck = key.toLowerCase();\n      if (lck.indexOf('size') >= 0 || lck.indexOf('status') >= 0) continue;\n\n      // ignore inherited methods, meaningless 0 values, and bogus timestamps\n      // that are in the future (Microsoft Edge seems to sometimes produce these)\n      if (!(typeof val === 'number' && val >= 0)) continue;\n      val = Math.round(val);\n      this.storeSTN({\n        n: key,\n        s: val,\n        e: val,\n        o: 'document',\n        t: 'timing'\n      });\n    }\n  }\n\n  // Tracks the events and their listener's duration on objects wrapped by wrap-events.\n  storeEvent(currentEvent, target, start, end) {\n    if (this.shouldIgnoreEvent(currentEvent, target)) return;\n    const evt = {\n      n: this.evtName(currentEvent.type),\n      s: start,\n      e: end,\n      t: 'event'\n    };\n    try {\n      // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n      // it does not check currentEvent.currentTarget before calling getRootNode() on it\n      evt.o = this.evtOrigin(currentEvent.target, target);\n    } catch (e) {\n      evt.o = this.evtOrigin(null, target);\n    }\n    this.storeSTN(evt);\n  }\n  shouldIgnoreEvent(event, target) {\n    const origin = this.evtOrigin(event.target, target);\n    if (event.type in ignoredEvents.global) return true;\n    if (!!ignoredEvents[origin] && ignoredEvents[origin].ignoreAll) return true;\n    return !!(!!ignoredEvents[origin] && event.type in ignoredEvents[origin]);\n  }\n  evtName(type) {\n    switch (type) {\n      case 'keydown':\n      case 'keyup':\n      case 'keypress':\n        return 'typing';\n      case 'mousemove':\n      case 'mouseenter':\n      case 'mouseleave':\n      case 'mouseover':\n      case 'mouseout':\n        return 'mousing';\n      case 'scroll':\n        return 'scrolling';\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchend':\n      case 'touchcancel':\n      case 'touchenter':\n      case 'touchleave':\n        return 'touching';\n      default:\n        return type;\n    }\n  }\n  evtOrigin(t, target) {\n    let origin = 'unknown';\n    if (t && t instanceof XMLHttpRequest) {\n      const params = this.ee.context(t).params;\n      if (!params || !params.status || !params.method || !params.host || !params.pathname) return 'xhrOriginMissing';\n      origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname;\n    } else if (t && typeof t.tagName === 'string') {\n      origin = t.tagName.toLowerCase();\n      if (t.id) origin += '#' + t.id;\n      if (t.className) {\n        for (let i = 0; i < t.classList.length; i++) origin += '.' + t.classList[i];\n      }\n    }\n    if (origin === 'unknown') {\n      if (typeof target === 'string') origin = target;else if (target === document) origin = 'document';else if (target === window) origin = 'window';else if (target instanceof FileReader) origin = 'FileReader';\n    }\n    return origin;\n  }\n\n  // Tracks when the window history API specified by wrap-history is used.\n  storeHist(path, old, time) {\n    const node = {\n      n: 'history.pushState',\n      s: time,\n      e: time,\n      o: path,\n      t: old\n    };\n    this.storeSTN(node);\n  }\n  #laststart = 0;\n  // Processes all the PerformanceResourceTiming entries captured (by observer).\n  storeResources(resources) {\n    if (!resources || resources.length === 0) return;\n    resources.forEach(currentResource => {\n      if ((currentResource.fetchStart | 0) <= this.#laststart) return; // don't recollect already-seen resources\n\n      const parsed = parseUrl(currentResource.name);\n      const res = {\n        n: currentResource.initiatorType,\n        s: currentResource.fetchStart | 0,\n        e: currentResource.responseEnd | 0,\n        o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname,\n        // resource.name is actually a URL so it's the source\n        t: currentResource.entryType\n      };\n      this.storeSTN(res);\n    });\n    this.#laststart = resources[resources.length - 1].fetchStart | 0;\n  }\n\n  // JavascriptError (FEATURE) events pipes into ST here.\n  storeErrorAgg(type, name, params, metrics) {\n    if (type !== 'err') return; // internal errors are purposefully ignored\n    const node = {\n      n: 'error',\n      s: metrics.time,\n      e: metrics.time,\n      o: params.message,\n      t: params.stackHash\n    };\n    this.storeSTN(node);\n  }\n\n  // Ajax (FEATURE) events--XML & fetches--pipes into ST here.\n  storeXhrAgg(type, name, params, metrics) {\n    if (type !== 'xhr') return;\n    const node = {\n      n: 'Ajax',\n      s: metrics.time,\n      e: metrics.time + metrics.duration,\n      o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n      t: 'ajax'\n    };\n    this.storeSTN(node);\n  }\n\n  // Central function called by all the other store__ & addToTrace API to append a trace node.\n  storeSTN(stn) {\n    if (this.nodeCount >= this.maxNodesPerHarvest) {\n      // limit the amount of pending data awaiting next harvest\n      if (this.isStandalone || this.agentRuntime.session.state.sessionTraceMode !== MODE.ERROR) return;\n      const openedSpace = this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // but maybe we could make some space by discarding irrelevant nodes if we're in sessioned Error mode\n      if (openedSpace === 0) return;\n    }\n    if (this.isStandalone && now() >= MAX_TRACE_DURATION) {\n      return;\n    }\n    if (this.trace[stn.n]) this.trace[stn.n].push(stn);else this.trace[stn.n] = [stn];\n    this.nodeCount++;\n  }\n\n  /**\n   * Trim the collection of nodes awaiting harvest such that those seen outside a certain span of time are discarded.\n   * @param {number} lookbackDuration Past length of time until now for which we care about nodes, in milliseconds\n   * @returns {number} However many nodes were discarded after trimming.\n   */\n  trimSTNs(lookbackDuration) {\n    let prunedNodes = 0;\n    const cutoffHighResTime = Math.max(now() - lookbackDuration, 0);\n    Object.keys(this.trace).forEach(nameCategory => {\n      const nodeList = this.trace[nameCategory];\n      /* Notice nodes are appending under their name's list as they end and are stored. This means each list is already (roughly) sorted in chronological order by end time.\n       * This isn't exact since nodes go through some processing & EE handlers chain, but it's close enough as we still capture nodes whose duration overlaps the lookback window.\n       * ASSUMPTION: all 'end' timings stored are relative to timeOrigin (DOMHighResTimeStamp) and not Unix epoch based. */\n      let cutoffIdx = nodeList.findIndex(node => cutoffHighResTime <= node.e);\n      if (cutoffIdx === 0) return;else if (cutoffIdx < 0) {\n        // whole list falls outside lookback window and is irrelevant\n        cutoffIdx = nodeList.length;\n        delete this.trace[nameCategory];\n      } else nodeList.splice(0, cutoffIdx); // chop off everything outside our window i.e. before the last <lookbackDuration> timeframe\n\n      this.nodeCount -= cutoffIdx;\n      prunedNodes += cutoffIdx;\n    });\n    return prunedNodes;\n  }\n\n  // Used by session trace's harvester to create the payload body.\n  takeSTNs(retry) {\n    if (!this.resourceObserver) {\n      // if PO isn't supported, this checks resourcetiming buffer every harvest.\n      this.storeResources(window.performance.getEntriesByType('resource'));\n    }\n    let earliestTimeStamp = Infinity;\n    const stns = Object.entries(this.trace).flatMap(_ref3 => {\n      let [name, listOfSTNodes] = _ref3;\n      // basically take the \"this.trace\" map-obj and concat all the list-type values\n      const oldestNodeTS = listOfSTNodes.reduce((acc, next) => !acc || next.s < acc ? next.s : acc, undefined);\n      if (oldestNodeTS < earliestTimeStamp) earliestTimeStamp = oldestNodeTS;\n      if (!(name in toAggregate)) return listOfSTNodes;\n      // Special processing for event nodes dealing with user inputs:\n      const reindexByOriginFn = this.smearEvtsByOrigin(name);\n      const partitionListByOriginMap = listOfSTNodes.sort((a, b) => a.s - b.s).reduce(reindexByOriginFn, {});\n      return Object.values(partitionListByOriginMap).flat(); // join the partitions back into 1-D, now ordered by origin then start time\n    }, this);\n    if (stns.length === 0) return {};\n    if (retry) {\n      this.sentTrace = this.trace;\n    }\n    this.trace = {};\n    this.nodeCount = 0;\n    let firstHarvestOfSession;\n    if (this.agentRuntime.session) {\n      const isFirstPayload = !this.agentRuntime.session.state.traceHarvestStarted;\n      firstHarvestOfSession = {\n        fsh: Number(isFirstPayload)\n      }; // converted to '0' | '1'\n      if (isFirstPayload) this.agentRuntime.session.write({\n        traceHarvestStarted: true\n      });\n    }\n    return {\n      qs: {\n        st: this.agentRuntime.offset,\n        /** hr === \"hasReplay\" in NR1, standalone is always checked and processed before harvesting\n         * so a race condition between ST and SR states should not be a concern if implemented here */\n        hr: Number(!this.isStandalone),\n        /** fts === \"firstTimestamp\" in NR1, indicates what the earliest NODE timestamp was\n         * so that blob parsing doesn't need to happen to support UI/API functions  */\n        fts: this.agentRuntime.offset + earliestTimeStamp,\n        /** n === \"nodeCount\" in NR1, a count of nodes in the ST payload, so that blob parsing doesn't need to happen to support UI/API functions */\n        n: stns.length,\n        // node count\n        ...firstHarvestOfSession\n      },\n      body: {\n        res: stns\n      }\n    };\n  }\n  smearEvtsByOrigin(name) {\n    const maxGap = toAggregate[name][0];\n    const maxLen = toAggregate[name][1];\n    const lastO = {};\n    return (byOrigin, evtNode) => {\n      let lastArr = byOrigin[evtNode.o];\n      if (!lastArr) lastArr = byOrigin[evtNode.o] = [];\n      const last = lastO[evtNode.o];\n      if (name === 'scrolling' && !trivial(evtNode)) {\n        lastO[evtNode.o] = null;\n        evtNode.n = 'scroll';\n        lastArr.push(evtNode);\n      } else if (last && evtNode.s - last.s < maxLen && last.e > evtNode.s - maxGap) {\n        last.e = evtNode.e;\n      } else {\n        lastO[evtNode.o] = evtNode;\n        lastArr.push(evtNode);\n      }\n      return byOrigin;\n    };\n    function trivial(node) {\n      const limit = 4;\n      return !!(node && typeof node.e === 'number' && typeof node.s === 'number' && node.e - node.s < limit);\n    }\n  }\n}","import { getConfigurationValue } from '../../../common/config/config';\nimport { gosNREUM } from '../../../common/window/nreum';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { MODE } from '../../../common/session/constants';\n\n/**\n * Figure out if the Replay feature is running (what mode it's in).\n * IMPORTANT: Session tracking is assumed to be ON; if applicable, check init's privacy.cookies_enabled setting before using this fn!\n * CRITICAL: This fn must be called prior to ALL features aggregate draining. If not, it will never resolve.\n * @param {String} agentId\n * @returns Promise that resolves to one of the values in MODE enum\n */\nexport async function getSessionReplayMode(agentId) {\n  try {\n    const newrelic = gosNREUM();\n    // Should be enabled by configuration and using an agent build that includes it (via checking that the instrument class was initialized).\n    if (getConfigurationValue(agentId, 'session_replay.enabled') && typeof newrelic.initializedAgents[agentId].features.session_replay === 'object') {\n      const srInitialized = await newrelic.initializedAgents[agentId].features.session_replay.onAggregateImported;\n      if (srInitialized) return await sharedChannel.sessionReplayInitialized; // wait for replay to determine which mode it's after running its sampling logic\n    }\n  } catch (e) {/* exception ==> off */}\n  return MODE.OFF; // at any step of the way s.t. SR cannot be on by implication or is explicitly off\n}","import classApplyDescriptorSet from \"./classApplyDescriptorSet.js\";\nimport classExtractFieldDescriptor from \"./classExtractFieldDescriptor.js\";\nexport default function _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}","export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","HarvestScheduler","SharedContext","constructor","endpoint","opts","parent","_this$sharedContext","super","this","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","ee","on","SESSION_EVENTS","RESET","runHarvest","forceNoRetry","onUnload","startTimer","interval","initialDelay","scheduleHarvest","stopTimer","permanently","arguments","length","undefined","clearTimeout","delay","setTimeout","cbRanAfterSend","result","retry","onHarvestFinished","submitMethod","payload","harvests","getPayload","submitData","isFinalHarvest","prototype","toString","call","push","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","isWorkerScope","globalScope","cleanupTasks","origClose","close","task","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","HandlerCache","_classPrivateMethodInitSpec","_close","_drain","_classPrivateFieldInitSpec","_decision","writable","value","_cache","_settleTimer","_classPrivateMethodGet","_close2","_noMoreChanges","settle","handler","_classPrivateFieldGet","decide","decision","_classPrivateFieldSet","_drain2","permanentlyDecide","h","ignoredEvents","global","mouseup","mousedown","window","load","pagehide","xhrOriginMissing","ignoreAll","toAggregate","typing","scrolling","mousing","touching","MAX_TRACE_DURATION","_scheduler","WeakMap","_onHarvestFinished","WeakSet","_prepareHarvest","_laststart","Aggregate","AggregateBase","agentIdentifier","aggregator","argsObj","_this","FEATURE_NAME","agentRuntime","getRuntime","xhrWrappable","resourceObserver","ptid","trace","nodeCount","sentTrace","harvestTimeSeconds","getConfigurationValue","maxNodesPerHarvest","isStandalone","operationalGate","sessionEntity","session","controlTraceOp","traceMode","MODE","ERROR","startTracing","FULL","OFF","mostRecentModeKnown","seenAnError","UPDATE","eventType","sessionState","sessionReplayMode","switchToFull","_this$agentRuntime","state","prevMode","write","sessionTraceMode","trimSTNs","needResponse","registerHandler","featureName","stopTracePerm","_classPrivateFieldGet2","_classPrivateFieldGet3","waitForFlags","then","async","traceOn","replayOn","_ref","RESUME","updatedTraceMode","PAUSE","isNew","replayMode","agentId","newrelic","gosNREUM","initializedAgents","features","session_replay","onAggregateImported","e","getSessionReplayMode","startingMode","_len","Array","_key","storeEvent","_len2","_key2","storeResources","_len3","_key3","storeHist","_len4","_key4","storeXhrAgg","_len5","_key5","storeSTN","_len6","_key6","storeErrorAgg","_len7","_key7","processPVT","drain","startupBuffer","dontStartHarvestYet","PerformanceNavigationTiming","storeTiming","performance","getEntriesByType","timing","_onHarvestFinished2","_prepareHarvest2","name","attrs","fid","hasFID","type","target","timingEntry","key","val","lck","toLowerCase","indexOf","Math","round","n","s","o","t","currentEvent","start","end","shouldIgnoreEvent","evt","evtName","evtOrigin","event","origin","XMLHttpRequest","params","context","status","method","host","pathname","tagName","id","className","i","classList","document","FileReader","path","old","time","node","resources","currentResource","fetchStart","parsed","parseUrl","res","initiatorType","responseEnd","protocol","hostname","port","entryType","metrics","message","stackHash","duration","stn","now","lookbackDuration","prunedNodes","cutoffHighResTime","max","keys","nameCategory","nodeList","cutoffIdx","findIndex","splice","takeSTNs","earliestTimeStamp","Infinity","stns","entries","flatMap","_ref3","listOfSTNodes","oldestNodeTS","reduce","acc","next","reindexByOriginFn","smearEvtsByOrigin","partitionListByOriginMap","sort","a","b","values","flat","firstHarvestOfSession","isFirstPayload","traceHarvestStarted","fsh","Number","qs","st","offset","hr","fts","body","maxGap","maxLen","lastO","byOrigin","evtNode","lastArr","last","limit","trivial","responseText","_ref2","concat","options","currentMode","_defineProperty","receiver","privateMap","descriptor","set","TypeError","classExtractFieldDescriptor"],"sourceRoot":""}