{"version":3,"file":"static/js/session_replay-aggregate.79bd8681.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/aggregate/index.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/shared/stylesheet-evaluator.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js","../node_modules/@babel/runtime/helpers/esm/classApplyDescriptorSet.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/constants';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/*\n * Copyright 2023 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @file Records, aggregates, and harvests session replay data.\n *\n * NOTE: This code is under development and dormant. It will not download to instrumented pages or record any data.\n * It is not production ready, and is not intended to be imported or implemented in any build of the browser agent until\n * functionality is validated and a full user experience is curated.\n */\n\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { ABORT_REASONS, FEATURE_NAME, MAX_PAYLOAD_SIZE, QUERY_PARAM_PADDING, RRWEB_EVENT_TYPES } from '../constants';\nimport { getConfigurationValue, getInfo, getRuntime } from '../../../common/config/config';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { warn } from '../../../common/util/console';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { RRWEB_VERSION } from \"../../../common/constants/env.npm\";\nimport { now } from '../../../common/timing/now';\nimport { MODE, SESSION_EVENTS, SESSION_EVENT_TYPES } from '../../../common/session/constants';\nimport { stringify } from '../../../common/util/stringify';\nimport { stylesheetEvaluator } from '../shared/stylesheet-evaluator';\nlet gzipper, u8;\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  // pass the recorder into the aggregator\n  constructor(agentIdentifier, aggregator, args) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    /** The interval to harvest at.  This gets overridden if the size of the payload exceeds certain thresholds */\n    this.harvestTimeSeconds = getConfigurationValue(this.agentIdentifier, 'session_replay.harvestTimeSeconds') || 60;\n    /** Set once the recorder has fully initialized after flag checks and sampling */\n    this.initialized = false;\n    /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */\n    this.blocked = false;\n    /** can shut off efforts to compress the data */\n    this.shouldCompress = true;\n    /** the mode to start in.  Defaults to off */\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    this.mode = session.state.sessionReplayMode || MODE.OFF;\n\n    /** set by BCS response */\n    this.entitled = false;\n    this.recorder = args?.recorder;\n    if (this.recorder) this.recorder.parent = this;\n    const shouldSetup = getConfigurationValue(agentIdentifier, 'privacy.cookies_enabled') === true && getConfigurationValue(agentIdentifier, 'session_trace.enabled') === true;\n    if (shouldSetup) {\n      // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n      this.ee.on(SESSION_EVENTS.RESET, () => {\n        this.scheduler.runHarvest();\n        this.abort(ABORT_REASONS.RESET);\n      });\n\n      // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n      this.ee.on(SESSION_EVENTS.PAUSE, () => {\n        this.recorder?.stopRecording();\n      });\n      // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n      this.ee.on(SESSION_EVENTS.RESUME, () => {\n        if (!this.recorder) return;\n        // if the mode changed on a different tab, it needs to update this instance to match\n        const {\n          session\n        } = getRuntime(this.agentIdentifier);\n        this.mode = session.state.sessionReplayMode;\n        if (!this.initialized || this.mode === MODE.OFF) return;\n        this.recorder?.startRecording();\n      });\n      this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n        if (!this.recorder || !this.initialized || this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n        if (this.mode !== MODE.OFF && data.sessionReplayMode === MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);\n        this.mode = data.sessionReplay;\n      });\n\n      // Bespoke logic for blobs endpoint.\n      this.scheduler = new HarvestScheduler('browser/blobs', {\n        onFinished: this.onHarvestFinished.bind(this),\n        retryDelay: this.harvestTimeSeconds,\n        getPayload: this.prepareHarvest.bind(this),\n        raw: true\n      }, this);\n      registerHandler('recordReplay', () => {\n        // if it has aborted or BCS returned bad entitlements, do not allow\n        if (this.blocked || !this.entitled) return;\n        // if it isnt already (fully) initialized... initialize it\n        if (!this.recorder) this.initializeRecording(false, true, true);\n        // its been initialized and imported the recorder but its not recording (mode === off || error)\n        else if (this.mode !== MODE.FULL) this.switchToFull();\n        // if it gets all the way to here, that means a full session is already recording... do nothing\n      }, this.featureName, this.ee);\n      registerHandler('pauseReplay', () => {\n        this.forceStop(this.mode !== MODE.ERROR);\n      }, this.featureName, this.ee);\n\n      // Wait for an error to be reported.  This currently is wrapped around the \"Error\" feature.  This is a feature-feature dependency.\n      // This was to ensure that all errors, including those on the page before load and those handled with \"noticeError\" are accounted for. Needs evalulation\n      registerHandler('errorAgg', e => {\n        this.errorNoticed = true;\n        if (this.recorder) this.recorder.currentBufferTarget.hasError = true;\n        // run once\n        if (this.mode === MODE.ERROR && globalScope?.document.visibilityState === 'visible') {\n          this.switchToFull();\n        }\n      }, this.featureName, this.ee);\n      this.waitForFlags(['sr']).then(_ref => {\n        let [flagOn] = _ref;\n        this.entitled = flagOn;\n        if (!this.entitled && this.recorder?.recording) this.recorder.abort(ABORT_REASONS.ENTITLEMENTS);\n        this.initializeRecording(Math.random() * 100 < getConfigurationValue(this.agentIdentifier, 'session_replay.error_sampling_rate'), Math.random() * 100 < getConfigurationValue(this.agentIdentifier, 'session_replay.sampling_rate'));\n      }).then(() => sharedChannel.onReplayReady(this.mode)); // notify watchers that replay started with the mode\n\n      this.drain();\n    }\n  }\n  switchToFull() {\n    this.mode = MODE.FULL;\n    // if the error was noticed AFTER the recorder was already imported....\n    if (this.recorder && this.initialized) {\n      this.recorder.stopRecording();\n      this.recorder.startRecording();\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n      this.syncWithSessionManager({\n        sessionReplayMode: this.mode\n      });\n    }\n  }\n\n  /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} entitlements - the true/false state of the \"sr\" flag from RUM response\n   * @param {boolean} errorSample - the true/false state of the error sampling decision\n   * @param {boolean} fullSample - the true/false state of the full sampling decision\n   * @param {boolean} ignoreSession - whether to force the method to ignore the session state and use just the sample flags\n   * @returns {void}\n   */\n  async initializeRecording(errorSample, fullSample, ignoreSession) {\n    this.initialized = true;\n    if (!this.entitled) return;\n\n    // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n    // if not, these sample flags need to be checked\n    // if this isnt the FIRST load of a session AND\n    // we are not actively recording SR... DO NOT import or run the recording library\n    // session replay samples can only be decided on the first load of a session\n    // session replays can continue if already in progress\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    if (!session.isNew && !ignoreSession) {\n      // inherit the mode of the existing session\n      this.mode = session.state.sessionReplayMode;\n    } else {\n      // The session is new... determine the mode the new session should start in\n      if (fullSample) this.mode = MODE.FULL; // full mode has precedence over error mode\n      else if (errorSample) this.mode = MODE.ERROR;\n      // If neither are selected, then don't record (early return)\n      else {\n        return;\n      }\n    }\n    if (!this.recorder) {\n      try {\n        // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n        const {\n          Recorder\n        } = await import( /* webpackChunkName: \"recorder\" */'../shared/recorder');\n        this.recorder = new Recorder(this);\n        this.recorder.currentBufferTarget.hasError = this.errorNoticed;\n      } catch (err) {\n        return this.abort(ABORT_REASONS.IMPORT);\n      }\n    }\n\n    // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n    if (this.mode === MODE.ERROR && this.errorNoticed) {\n      this.mode = MODE.FULL;\n    }\n\n    // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n    // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n    // If an error happened in ERROR mode before we've gotten to this stage, it will have already set the mode to FULL\n    if (this.mode === MODE.FULL && !this.scheduler.started) {\n      // We only report (harvest) in FULL mode\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      const {\n        gzipSync,\n        strToU8\n      } = await import( /* webpackChunkName: \"compressor\" */'fflate');\n      gzipper = gzipSync;\n      u8 = strToU8;\n    } catch (err) {\n      // compressor failed to load, but we can still record without compression as a last ditch effort\n      this.shouldCompress = false;\n    }\n    if (!this.recorder.recording) this.recorder.startRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n  prepareHarvest() {\n    if (!this.recorder) return;\n    const recorderEvents = this.recorder.getEvents();\n    // get the event type and use that to trigger another harvest if needed\n    if (!recorderEvents.events.length || this.mode !== MODE.FULL || this.blocked) return;\n    const payload = this.getHarvestContents(recorderEvents);\n    if (!payload.body.length) {\n      this.recorder.clearBuffer();\n      return;\n    }\n    let len = 0;\n    if (this.shouldCompress) {\n      payload.body = gzipper(u8(\"[\".concat(payload.body.map(e => e.__serialized).join(','), \"]\")));\n      len = payload.body.length;\n      this.scheduler.opts.gzip = true;\n    } else {\n      payload.body = payload.body.map(_ref2 => {\n        let {\n          __serialized,\n          ...node\n        } = _ref2;\n        return node;\n      });\n      len = stringify(payload.body).length;\n      this.scheduler.opts.gzip = false;\n    }\n    if (len > MAX_PAYLOAD_SIZE) {\n      this.abort(ABORT_REASONS.TOO_BIG);\n      return;\n    }\n    // TODO -- Gracefully handle the buffer for retries.\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    if (!session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n      sessionReplaySentFirstChunk: true\n    });\n    this.recorder.clearBuffer();\n    if (recorderEvents.type === 'preloaded') this.scheduler.runHarvest();\n    return [payload];\n  }\n  getHarvestContents(recorderEvents) {\n    recorderEvents ??= this.recorder.getEvents();\n    let events = recorderEvents.events;\n    const agentRuntime = getRuntime(this.agentIdentifier);\n    const info = getInfo(this.agentIdentifier);\n    const endUserId = info.jsAttributes?.['enduser.id'];\n\n    // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n    // we will manually inject it if this happens\n    const payloadStartsWithFullSnapshot = events?.[0]?.type === RRWEB_EVENT_TYPES.FullSnapshot;\n    if (payloadStartsWithFullSnapshot && !!this.recorder.lastMeta) {\n      recorderEvents.hasMeta = true;\n      events.unshift(this.recorder.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n      this.recorder.lastMeta = undefined;\n    }\n\n    // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n    // we will manually inject it later if we find a payload that is missing a meta node\n    const payloadEndsWithMeta = events[events.length - 1]?.type === RRWEB_EVENT_TYPES.Meta;\n    if (payloadEndsWithMeta) {\n      this.recorder.lastMeta = events[events.length - 1];\n      events = events.slice(0, events.length - 1);\n      recorderEvents.hasMeta = !!events.find(x => x.type === RRWEB_EVENT_TYPES.Meta);\n    }\n    const agentOffset = getRuntime(this.agentIdentifier).offset;\n    const relativeNow = now();\n    const firstEventTimestamp = events[0]?.timestamp; // from rrweb node\n    const lastEventTimestamp = events[events.length - 1]?.timestamp; // from rrweb node\n    const firstTimestamp = firstEventTimestamp || recorderEvents.cycleTimestamp;\n    const lastTimestamp = lastEventTimestamp || agentOffset + relativeNow;\n    return {\n      qs: {\n        browser_monitoring_key: info.licenseKey,\n        type: 'SessionReplay',\n        app_id: info.applicationID,\n        protocol_version: '0',\n        attributes: encodeObj({\n          // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n          // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n          ...(this.shouldCompress && {\n            content_encoding: 'gzip'\n          }),\n          'replay.firstTimestamp': firstTimestamp,\n          'replay.firstTimestampOffset': firstTimestamp - agentOffset,\n          'replay.lastTimestamp': lastTimestamp,\n          'replay.durationMs': lastTimestamp - firstTimestamp,\n          'replay.nodes': events.length,\n          'session.durationMs': agentRuntime.session.getDuration(),\n          agentVersion: agentRuntime.version,\n          session: agentRuntime.session.state.value,\n          rst: relativeNow,\n          hasMeta: recorderEvents.hasMeta || false,\n          hasSnapshot: recorderEvents.hasSnapshot || false,\n          hasError: recorderEvents.hasError || false,\n          isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n          decompressedBytes: recorderEvents.payloadBytesEstimation,\n          invalidStylesheetsDetected: stylesheetEvaluator.invalidStylesheetsDetected,\n          inlinedAllStylesheets: recorderEvents.inlinedAllStylesheets,\n          'rrweb.version': RRWEB_VERSION,\n          // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n          ...(endUserId && {\n            'enduser.id': endUserId\n          })\n          // The Query Param is being arbitrarily limited in length here.  It is also applied when estimating the size of the payload in getPayloadSize()\n        }, QUERY_PARAM_PADDING).substring(1) // remove the leading '&'\n      },\n      body: events\n    };\n  }\n  onHarvestFinished(result) {\n    // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n    if (result.status === 429) {\n      this.abort(ABORT_REASONS.TOO_MANY);\n    }\n    if (this.blocked) this.scheduler.stopTimer(true);\n  }\n\n  /**\n   * Forces the agent into OFF mode so that changing tabs or navigating\n   * does not restart the recording. This is used when the customer calls\n   * the stopRecording API.\n   */\n  forceStop(forceHarvest) {\n    if (forceHarvest) this.scheduler.runHarvest();\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    warn(\"SR aborted -- \".concat(reason.message));\n    handle(SUPPORTABILITY_METRIC_CHANNEL, [\"SessionReplay/Abort/\".concat(reason.sm)], undefined, FEATURE_NAMES.metrics, this.ee);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n    this.recorder?.clearTimestamps?.();\n    this.ee.emit('REPLAY_ABORTED');\n    this.recorder?.clearBuffer?.();\n  }\n  syncWithSessionManager() {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    session.write(state);\n  }\n}","import { originals } from '../../../common/config/config';\nimport { isBrowserScope } from '../../../common/constants/runtime';\nclass StylesheetEvaluator {\n  #evaluated = new WeakSet();\n  #fetchProms = [];\n  /**\n  * Flipped to true if stylesheets that cannot be natively inlined are detected by the stylesheetEvaluator class\n  * Used at harvest time to denote that all subsequent payloads are subject to this and customers should be advised to handle crossorigin decoration\n  * */\n  invalidStylesheetsDetected = false;\n  failedToFix = false;\n\n  /**\n   * this works by checking (only ever once) each cssRules obj in the style sheets array. The try/catch will catch an error if the cssRules obj blocks access, triggering the module to try to \"fix\" the asset`. Returns the count of incomplete assets discovered.\n   * @returns {Number}\n   */\n  evaluate() {\n    let incompletes = 0;\n    if (isBrowserScope) {\n      for (let i = 0; i < Object.keys(document.styleSheets).length; i++) {\n        const ss = document.styleSheets[i];\n        if (!this.#evaluated.has(ss)) {\n          this.#evaluated.add(ss);\n          try {\n            // eslint-disable-next-line\n            const temp = ss.cssRules;\n          } catch (err) {\n            incompletes++;\n            this.#fetchProms.push(this.#fetchAndOverride(document.styleSheets[i], ss.href));\n          }\n        }\n      }\n    }\n    if (incompletes) this.invalidStylesheetsDetected = true;\n    return incompletes;\n  }\n\n  /**\n   * Resolves promise once all stylesheets have been fetched and overridden\n   * @returns {Promise}\n   */\n  async fix() {\n    await Promise.all(this.#fetchProms);\n    this.#fetchProms = [];\n    const failedToFix = this.failedToFix;\n    this.failedToFix = false;\n    return failedToFix;\n  }\n\n  /**\n  * Fetches stylesheet contents and overrides the target getters\n  * @param {*} target - The stylesheet object target - ex. document.styleSheets[0]\n  * @param {*} href - The asset href to fetch\n  * @returns {Promise}\n  */\n  async #fetchAndOverride(target, href) {\n    const stylesheetContents = await originals.FETCH.bind(window)(href);\n    if (!stylesheetContents.ok) {\n      this.failedToFix = true;\n      return;\n    }\n    const stylesheetText = await stylesheetContents.text();\n    try {\n      const cssSheet = new CSSStyleSheet();\n      await cssSheet.replace(stylesheetText);\n      Object.defineProperty(target, 'cssRules', {\n        get() {\n          return cssSheet.cssRules;\n        }\n      });\n      Object.defineProperty(target, 'rules', {\n        get() {\n          return cssSheet.rules;\n        }\n      });\n    } catch (err) {\n      // cant make new dynamic stylesheets, browser likely doesn't support `.replace()`...\n      // this is appended in prep of forking rrweb\n      Object.defineProperty(target, 'cssText', {\n        get() {\n          return stylesheetText;\n        }\n      });\n      this.failedToFix = true;\n    }\n  }\n}\nexport const stylesheetEvaluator = new StylesheetEvaluator();","import classApplyDescriptorSet from \"./classApplyDescriptorSet.js\";\nimport classExtractFieldDescriptor from \"./classExtractFieldDescriptor.js\";\nexport default function _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}","export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","HarvestScheduler","SharedContext","constructor","endpoint","opts","parent","_this$sharedContext","super","this","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","ee","on","SESSION_EVENTS","RESET","runHarvest","forceNoRetry","onUnload","startTimer","interval","initialDelay","scheduleHarvest","stopTimer","permanently","arguments","length","undefined","clearTimeout","delay","setTimeout","cbRanAfterSend","result","retry","onHarvestFinished","submitMethod","payload","harvests","getPayload","submitData","isFinalHarvest","prototype","toString","call","push","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","isWorkerScope","globalScope","cleanupTasks","origClose","close","task","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","gzipper","u8","Aggregate","AggregateBase","agentIdentifier","aggregator","FEATURE_NAME","harvestTimeSeconds","getConfigurationValue","initialized","blocked","shouldCompress","session","getRuntime","mode","state","sessionReplayMode","MODE","OFF","entitled","recorder","scheduler","abort","ABORT_REASONS","PAUSE","_this$recorder","stopRecording","RESUME","_this$recorder2","startRecording","UPDATE","type","data","SESSION_EVENT_TYPES","CROSS_TAB","sessionReplay","prepareHarvest","registerHandler","FULL","switchToFull","initializeRecording","featureName","forceStop","ERROR","e","errorNoticed","currentBufferTarget","hasError","document","visibilityState","waitForFlags","then","_ref","_this$recorder3","flagOn","recording","ENTITLEMENTS","Math","random","drain","syncWithSessionManager","errorSample","fullSample","ignoreSession","isNew","Recorder","err","IMPORT","gzipSync","strToU8","recorderEvents","getEvents","events","getHarvestContents","body","clearBuffer","len","concat","map","__serialized","join","gzip","_ref2","node","stringify","MAX_PAYLOAD_SIZE","TOO_BIG","sessionReplaySentFirstChunk","_recorderEvents","_info$jsAttributes","_events","_events2","_events$","_events3","agentRuntime","info","getInfo","endUserId","jsAttributes","RRWEB_EVENT_TYPES","FullSnapshot","lastMeta","hasMeta","unshift","Meta","slice","find","x","agentOffset","offset","relativeNow","now","firstEventTimestamp","timestamp","lastEventTimestamp","firstTimestamp","cycleTimestamp","lastTimestamp","qs","browser_monitoring_key","licenseKey","app_id","applicationID","protocol_version","attributes","encodeObj","content_encoding","getDuration","agentVersion","version","value","rst","hasSnapshot","isFirstChunk","decompressedBytes","payloadBytesEstimation","invalidStylesheetsDetected","stylesheetEvaluator","inlinedAllStylesheets","RRWEB_VERSION","QUERY_PARAM_PADDING","substring","status","TOO_MANY","forceHarvest","_this$recorder4","_this$recorder4$stopR","_this$recorder5","_this$recorder5$stopR","_this$recorder6","_this$recorder6$clear","_this$recorder7","_this$recorder7$clear","reason","warn","message","handle","SUPPORTABILITY_METRIC_CHANNEL","sm","FEATURE_NAMES","metrics","clearTimestamps","emit","write","_defineProperty","_evaluated","WeakMap","_fetchProms","_fetchAndOverride","WeakSet","_fetchAndOverride2","target","href","stylesheetContents","originals","FETCH","window","ok","failedToFix","stylesheetText","text","cssSheet","CSSStyleSheet","replace","defineProperty","get","cssRules","rules","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","evaluate","incompletes","i","keys","styleSheets","ss","_classPrivateFieldGet","has","add","_classPrivateMethodGet","fix","all","_classPrivateFieldSet","receiver","privateMap","descriptor","set","TypeError","classExtractFieldDescriptor"],"sourceRoot":""}